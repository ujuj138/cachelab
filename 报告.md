# 报告

##学习Linux基础使用

+ [笔记](linux课堂记录\linux.pdf)

+ 看完了推荐的课程，结合之前就会的一些linux基本操作，对于linux的理解又提高了一点，感觉收获很多。

+ 在学习的过程中都通过服务器进行验证学习，提高对于Linux命令行的熟练度，但是由于日常用的还是windows，所以还是不是很熟练，特别是正则表达式，只能看懂，写也只能写的比较简单。

##了解调试及性能分析工具

+ 在网上阅读了gdb的使用方法，此前在《计算机系统基础》这门课中也有学习

+ 安装了coredump和vtune等软件。

##cachelab

+ [过程笔记](过程.pdf)

+ 本次实验全部在服务器上运行，因为运行只需要make。

+ `valgringd ./csim -s 5 -E 1 -b 5 -t traces/long.trace`	
`valgringd ./test-trans -M 64 -N 64`查看内存泄漏状况

+ 运行`./drive.py`查看进行检查

###Part A

+ 代码主要分为3个部分，首先要学会读取Linux参数，这里参考了网上getopt()函数的编写方式，getopt()会把参数存在op中，参数带的数字存在optrang中，通过atol()将s, E, t参数存储到对应位置里，并且做了一些错误检查。

+ 第二部分是对于数据的读取，这部分使用malloc初始化cache，然后再利用fscanf读取t中文件的指令，并且进行运算。这部分最后要对FILE指针和malloc申请的地址进行释放，否则不会通过valgringd的测试。这些会在release函数中被释放。

+ 首先由说明书可以知道I命令不需要运行，然后S和L指令只需要一次运行，M指令要运行两次。

+ 这里对cache的结构体进行说明，cache整体是一个树状的结构, cache本体由参数和sets组成，而set由lines的链表构成, 因为本次实验对于block没有直接的使用，所以没有设置, 为了实现主要功能, lines由valid, tag, 以及为了实现Lru算法的lru。

+ 自带的参数描述cache的参数为s, E, b三个, s表示了sets的数量, 即(1 << s)个set, E是每个set中的lines个数，b表示每个block的字节大小(1 << b)。

+ 从文件中读取的指令由三个部分组成，这里对地址addr进行解析，地址由三个部分组成，即tag = (addr>>(s + b)), set index = ((addr >> b) & ((1 << s) - 1)), block(不需要处理)。 

+ 第三部分就是cache部分, 这部分需要模拟cache行为，主要要完成的功能为1. 使用lru算法进行替换。 2. 修改tag和valid模拟访问。3. 统计hit和miss。

+ `loadcache`时有三种情况，hit, miss, eviction。通过miss函数遍历cache所有sets和lines, 判断tag&valid是否正确。 如果不一样, 则miss, 否则hit并调用updateLru，更新line中的lru参数。 然后如果miss了，则需要考虑eviction的情况，显然只有该set中所有line都被占用才会导致该结果，所以只需要在被传入的set参数的set位置中考虑每个line是否被占用了即可。 如果没被占用，正常的修改tag和valid然后updatelru即可。如果满了就需要判断最小的lru的那一行并写入，而且进行updatelru, 并增加evictions的次数。


###Part B

+ 这部分是要修改`trans.c`中的`transpose_submit`函数, 然后输入的M和N为转置矩阵的行和列

+ 测试使用(s, E, b) = (5, 1, 5)的cache进行操作, 分别测试(N, M) = (32, 32), (64, 64), (61, 67)的矩阵。实验书也说明了只需要针对这三种情况就进行操作，因此只需要使用if..else来就可以了。

+ s = 5, 所以总共有32个set, E = 1, 所以每个set一行(说明不需要lru替换), b = 5, 所以block有32个字节， 在这里的矩阵都是4字节，所以一个block有8个int。

####32*32

+ 由[阻塞技术](\waside-blocking.pdf)中的代码可以知道实现的方法。

+ 实现降低Misses的理论是优先对存储在cache里的数据进行读取，等到数据用完后再进行下一个block的读取，这样就能降低了。

+ 由之前可以知道，每个block(每行)(每set)的都为8个int，一个cache可以占用8 * 8的矩阵。

+ 32 * 32中一行要4行cache。 所以考虑8 * 8的阻塞块，参考Pdf中的代码写出类似的，每次的步幅为8。但是此时验算为343。

+ 这时候要计算misses的次数，这里要考虑每次读完A之后写B这个过程中，在i=j的时候，B[i][j]会覆盖A的并会产生miss。所以在i = j 时必须先把A[i][j]读出来在这一行计算完后再转换。这样能有效减少miss。除此以外，这一点在pdf中有很多的提示。

+ 最终是8 * 32 + 32 个misses。

![](https://upload-images.jianshu.io/upload_images/10803273-bca96b5b9fba1a7a.jpg)
####64*64

+ 本来以为和之前类似，所以使用32 * 32的方式进行运算但是均失败, Misses次数很多。

+ 在网上看了很多资料，学习了一种方式，还是使用阻塞技术来降低，这次更加地巧妙。

+ 首先主要地思想是8 * 8中一行是8个int，但是通过不同行对应的cache, 按照之前的方法会导致多次miss。所以这里先将一行的4-7存储在B的后一列中。然后不断的重复这个过程。最终达到结果 ![](picture\64.png)

####61*67

+ 根据要求可以知道Miss的要求是低于2000，而在64 * 64时可以知道很轻易就能达到2000了。而在此处与64 * 64的矩阵规模相差不大。因此使用之前在64规模中失败的方法就可以了，但是要避免数组越界就行了。最终在16处得到满分，但是满分的方法英国很多。